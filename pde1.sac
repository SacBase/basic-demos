/*
 *  PDE1
 *
 *  3-Dimensional Poisson Solver Using Red-Black Relaxation  
 *  Benchmark 
 * 
 *  APL-like programming style version
 *  March 2000
 *  developed from the following original SAC implementation:
 *
 *  basic sac-version
 *  Jan-Hendrik Schoeler, March 1999, CAU
 *  developed from the following fortran-version:
 *
 *
 *  Original author:  Max Lemke (1989, PALLAS GmbH)
 *                    PALLAS GmbH                                  
 *                    Hermulheimer Str. 10                          
 *                    5040 Bruhl, GERMANY                           
 *                    tel.:+49-2232-18960   e-mail:karls@pallas-gmbh.de
 *                                                                 
 *       Subset HPF:  Vladimir Getov                      
 *                    (1993, University of Southampton)    
 *
 *  For numerical Verification:
 *     The average Convergence rate should be somewhere between 0.7 and 0.98
 */ 

import Array:all;
import ArrayIO:all;
import ScalarIO:all;
import Math:all;
import CommandLine: all;
import String: {
  implicit types: string;
  functions: strcmp, ==, toi;
}


/*
 *  Parameters for the algorithm.
 *
 *  N is the edgelength of the used threedimensional arrays. 
 *  N must be defined as 2^NN, to match the original Fortran-Code!!!
 *  
 *  NX, NY and NZ represent the edgelengths for each of the three dimensions.
 *  They are used in the code for the creation of the arrays.
 *  Each edge length may be set separately for improved flexibility.
 *  
 *  ITER is the default number of Iterarions to be computed.
 *  It may be overwritten at program startup with the -iter N command line option.
 *  Note: this must be the first option on the command line!
 *
 *  RELAX allows to choose among 4 different implementations of the relaxation kernel.
 */

#ifndef N
#define N 64 
#endif

#ifndef NX
#define NX N 
#endif

#ifndef NY
#define NY N 
#endif

#ifndef NZ
#define NZ N 
#endif

#ifndef ITER
#define ITER 10 
#endif

#ifndef RELAX
#define RELAX 3
#endif


/*
 * Ugly trick for preventing the compiler to apply WLF too often 8-((( :
 */

#define Z

/*
 *  g is the (given) Boundary value function from the poisson equation. 
 *  All three inputvalues or squared and added. 
 */
inline double g (double x, double y, double z)
{
  return (x * x + y * y + z * z);
}


/*
 *  Computes maximum norm of the defect. 
 *  u and f must have the same shape and dimension 3.
 */
inline double maxnorm (double[] u, double[] f, double h)
{
  fac = 1 / (h * h);

  /* 
   *  ! Inlined starsum could be used here!!!
   */
  u = with (. < iv < .)
      {
         val = fabs(f[iv] + fac * (-6d * u[iv] + 
                                   u[iv+[1,0,0]] + u[iv-[1,0,0]] +      
                                   u[iv+[0,1,0]] + u[iv-[0,1,0]] +
                                   u[iv+[0,0,1]] + u[iv-[0,0,1]]));
      }
      modarray (u, iv, val);

  return (maxval (u));
}

/* 
 *  Returns initial values for u, f, 
 *  where u and f are threedimensinal arrays of shape [NX,NY,NZ].
 *   
 */
inline double[], double[] init (double h)
{
  /* 
   *  Initialize u: inner points with 0 and the 6 sides with special values 
   */
  u = with ([0,0,0] <= [i,j,k] <= [0,NY-1,NZ-1])
      genarray ([NX,NY,NZ], g(0d, j*h, k*h));

  u = with ([NX-1,0,0] <= iv = [i,j,k] <= [NX-1,NY-1,NZ-1])
      modarray (u, iv, g((NX-1)*h,j*h, k*h)); 

  u = with ([0,0,0] <= iv = [i,j,k] <= [NX-1,0,NZ-1])
      modarray (u, iv, g(i*h,0d,k*h));

  u = with ([0,NY-1,0] <= iv = [i,j,k] <= [NX-1,NY-1,NZ-1])
      modarray (u, iv, g(i*h,(NY-1)*h,k*h));

  u = with ([0,0,0] <= iv = [i,j,k] <= [NX-1,NY-1,0])
      modarray (u, iv, g(i*h,j*h,0d));

  u = with ([0,0,NZ-1] <= iv = [i,j,k] <= [NX-1,NY-1,NZ-1])
      modarray (u, iv, g(i*h,j*h,(NZ-1)*h));

  /* 
   * Initialize f: inner points with 6, all other with 0 
   */ 
  f = with (. < iv < .)
      genarray ([NX,NY,NZ], 6d);

  return (u, f);
}

#define W reshape( [3,3,3],                                    \
                   [ 0d,0d,0d, 0d,1d,0d, 0d,0d,0d,             \
                     0d,1d,0d, 1d,0d,1d, 0d,1d,0d,             \
                     0d,0d,0d, 0d,1d,0d, 0d,0d,0d ])



/* 
 *   double[] relax (double[] u, double[] f, double hsq)
 *
 *   This is the essential routine of the algorithm, where all the work ist done.
 *   The relaxation on u ist to be done as many times as specified by iter. 
 *   u and f must be threedimensional arrays.
 *
 *   4 different implementations are provided, that thanks to with-loop folding
 *   boil down to almost identical intermediate codes and hence all yield roughly
 *   the same runtime performance.
 */


#if RELAX==1

/*
 * First implementation of relax kernel.
 *
 * The computation is specified in an elementwise and, more important, 
 * dimension-specific style.
 */

inline double[] relax (double[] u, double[] f, double hsq)
{
  factor = 1d/6d;

  u = with (. < iv < . )
      modarray (u, iv, factor * (hsq * f[iv] +
                                 u[iv+[1,0,0]] + u[iv-[1,0,0]] +
                                 u[iv+[0,1,0]] + u[iv-[0,1,0]] +
                                 u[iv+[0,0,1]] + u[iv-[0,0,1]] ));
  return (u);
}


#elif RELAX==2

/*
 * Second implementation of relax kernel.
 *
 * The computation is specified in a dimension-invariant style.
 * Moreover, it also abstracts completely from the stencil, which is provided
 * by means of the constant coefficient array W.
 */


#define tile( size, pos, a) with( .<= ivv <= .) genarray( size, a[pos+ivv])
/*
 * At the time being, the type checker is unable to resolve the type of the function
 * tile(). Therefore, we have to provide it as amacro here.
 */

inline double[] relax (double[] u, double[] f, double hsq)
{
  factor = 1d/6d;

    u = with (. < iv < . ) {
          block = tile( ([3,3,3]), iv-1, u);
          tmp = W * block;
          val = factor * (hsq * f[iv] + sum( tmp));
        } modarray( u, iv, val);

  return ( u);
}



#elif RELAX==3

/*
 * Third implementation of relax kernel.
 *
 * The computation is specified in an APL-like style, i.e. without any with-loop.
 * It is still dimension-invariant, but is fixed to the given stencil.
 */

inline double[] relax (double[] u, double[] f, double hsq)
{
  factor = 1d/6d;

  res = hsq * f;

  for (i=0; i<dim(u); i++) {
    res += shift( i, 1, 0d, u);
    res += shift( i, -1, 0d, u);
  }

  res = CombineInnerOuter( res*factor, u);

  return( res);
}


#elif RELAX==4

/*
 * Fourth implementation of relax kernel.
 *
 * This is yet another implementation  of the relaxation kernel that is both
 * dimension-invariant and stencil-invariant.
 *
 *
 * Warning:
 *
 *  This variant of relax needs REALLY a LOT of memory !!
 *  It must be compiled with  "-maxwlur 27" to achieve proper performance.
 */

inline double[] relax (double[] u, double[] f, double hsq)
{
  factor = 1d/6d;

  res = with ( 0*shape(W) <= iv < shape(W))
        fold( +, hsq * f, W[iv] * shift( 1-iv, 0d, u));

  res = CombineInnerOuter( res*factor, u);

  return( res);
}

#endif


/* 
 * This function creates a new array of the same shape as the two argument arrays.
 * All inner elements of the new array are taken from argument a, the outer ones
 * from argument b.
 */
inline double[] CombineInnerOuter(double[] a, double[] b)
{
  c = with ( . < iv < .)
      modarray( b, iv, a[iv]);
  
  return( c);
}

/*
 * This function creates a new array of the same shape as the two argument arrays.
 * All elements with an even index in the outermost dimension are taken from
 * argument array a, all others from argument array b.
 */
inline double[] CombineEvenOdd( double[] a, double[] b)
{
  step_vec = modarray( shape(a)*0+1 , [0], 2);

  c = with( .<= iv <= . step step_vec)
      genarray( shape(a), a[iv]);

  start_odd = modarray( shape(a)*0 , [0], 1);

  c = with( start_odd <= iv <= . step step_vec)
      modarray( c, iv, b[iv]);

  return( c);
}

/*
 * This is the realization of red/black relaxation.
 * Unfortunately, some dirty trick is currently needed to prevent limit with-loop
 * folding after the two applications of CombineEvenOdd( ) have been inlined.
 *
 * This undesired with-loop folding would lead to the replication of work and
 * hence would slow down program execution significantly.
 */
inline double[] RedBlack( double[] u, double[] f, double h, int iter)
{
  hsq = h * h;

  printf("Iterations starting.\n");

#ifdef Z
z=0d;
#endif

  nrel=1;
  do {

    u = CombineEvenOdd( u, relax(u, f, hsq));
#ifdef Z
    z += u[2,2,2];
#endif
    u = CombineEvenOdd( relax(u, f, hsq), u);

    nrel++;
  }
  while( nrel<=iter);

#ifdef Z
  printf("%g\n",z);
#endif

  printf("Iterations finished.\n");

  return(u);
}



/*
 * Rather simple checking for command line argument -iter <n>.
 * -iter must be the first argument, the second argument must be a number.
 * Further arguments are not supported.
 */
int CheckCommandline()
{
  if (argc()>2) {
    if (argv(1)=="-iter") {
      res = toi(argv(2));
    }
    else {
      res = ITER;
    }
  }
  else {
    res = ITER;
  }

  return( res);
}


/*
 * function main()
 */
int main()
{
  printf("PDE1\n");
  printf("3D RED BLACK RELAXATION BENCHMARK\n");

  iter = CheckCommandline();
  h = 1d / (NX - 1);

  /*
   *  Next five lines:
   *  1. u and f are initialized as threedimensinal arrays of shape [NX,NY,NZ].  
   *  2. The maximumnorm of u before the relaxation is calculated.
   *  3. The relaxation is done
   *  4. The maximumnorm of u after the relaxation is calculated.
   *  5. The convergence-rate of the relaxation is calculated, 
   *      by the two maximumnorm-values.
   */
  u, f = init (h);
  res1 = maxnorm(u,f,h);
  u = RedBlack (u, f, h, iter);
  res2 = maxnorm(u,f,h);
  convr = pow(res2/res1,0.1d); 

  /* 
   *  Printing results.
   */
  printf("Number of internal points per direction  = x%i y%i z%i\n", NX-2, NY-2, NZ-2);
  printf("Internal gridsize of cubic grid          = %i\n", (NX-2) * (NY-2) * (NZ - 2));
  printf("Average convergence rate (%i Iterations) = %g\n", iter, convr); 

  printf("STOP\n");
  return(0);
}
