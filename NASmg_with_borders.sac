import StdIO: all;
import MathC: all;
import String: all;
import Array: all;

/*
 * The following defines are needed for "telling" the compiler 
 * all possible input sizes. For more information see "main".
 */

#define S0 4
#define S1 6
#define S2 10
#define S3 18
#define S4 34
#define S5 66
#define S6 130
#define S7 258


/*
 * The following flags are used to create different versions:
 * DISTRIB_LAW_BUG_IS_FIXED indicates whether the compiler is capable
 *   to apply distributive law (1) or not (0).
 * USE_SAME_SHORTCUT_AS_IN_FORTRAN indicates whether the algorithm patch
 *   used in the Fortran version of the benchmark in order to spare one
 *   copy of the largest array should be applied in SAC as well (1) or not (0).
 */

#define DISTRIB_LAW_BUG_IS_FIXED 0
#define USE_SAME_SHORTCUT_AS_IN_FORTRAN 1

/* 
 * Now, we define the arrays of weights needed for relaxation (A),
 * restriction (P), extension (Q), and smoothing (S).
 * In the NAS-MG benchmark, all these have a particular property:
 * weights with the same "distance" from the "center" do have the same
 * value! Therefore, in the 3-dimensional case, they can be described
 * by a vector containing 4 values: 
 * [ center, distance 1, distance 2, distance 3]
 *
 * Another consequence of this property is that for the computation
 * of the required weighted sums the distributive law is applicable,
 * which leads to a noticable speedup in program execution.
 * Since the FORTRAN program is hand-optimized to this effect,
 * we have to make sure that the distributive law optimization
 * of the SAC compiler is turned on!
 */

#define AP [ -8d/3d, 0d    , 1d/6d  , 1d/12d]
#define PP [ 1d/2d , 1d/4d , 1d/8d  , 1d/16d]
#define QP [ 1d    , 1d/2d , 1d/4d  , 1d/8d ]
#define SP [ -3d/8d, 1d/32d, -1d/64d, 0d    ]

#define SHP [3,3,3]

#if DISTRIB_LAW_BUG_IS_FIXED

#define A gen_weights( AP)
#define P gen_weights( PP)
#define Q gen_weights( QP)
#define S gen_weights( SP)

inline double[] gen_weights( double[] wp)
{
  res = with( . <= iv <= . ) {
          off = with( 0*shape(iv) <= ix < shape(iv)) {
                  if( iv[ix] != 1)
                    dist = 1;
                  else 
                    dist = 0;
                } fold( +, dist);
        } genarray( SHP, wp[[off]]);
  return( res);
}
#else

/*
 * Since the actual SAC2C compiler due to a bug does not support
 * distributive law optimization, a modified version of the function
 * that computes the weighted sums ("weighted_sum") has to be used
 * which is hand optimized to that effect.
 * As a consequence, A, P, Q, and S are not arrays of weights of shape
 * SHP, but are only the carriers of different values needed for the
 * particularities of the NAS-MG benchmark.
 */

#define A AP
#define P PP
#define Q QP
#define S SP

#endif


double l2norm_inner( double[] u)
{
  sqrsum = with( 0*shape(u)+1 <= x<= shape(u)-2)
           fold( +, u[x]*u[x]);
  n_elem = with( [0] <= y <= [dim(u)-1])
           fold( *, shape(u)[y] -2);
  return( sqrt( sqrsum/n_elem));
}

double[] setup_periodic_border( double[] u)
{
  for( x=1; x<shape(u)[0]-1; x++) {
    for( y=1; y<shape(u)[1]-1; y++) {
      z = shape(u)[2];
      u = modarray( u, [x,y,0], u[[x,y,z-2]]);
      u = modarray( u, [x,y,z-1], u[[x,y,1]]);
    }
  }
 
  for( x=1; x<shape(u)[0]-1; x++) {
    y = shape(u)[1];
    for( z=0; z<shape(u)[2]; z++) {
      u = modarray( u, [x,0,z], u[[x,y-2,z]]);
      u = modarray( u, [x,y-1,z], u[[x,1,z]]);
    }
  }
 
  x = shape(u)[0];
  for( y=0; y<shape(u)[0]; y++) {
    for( z=0; z<shape(u)[2]; z++) {
      u = modarray( u, [0,y,z], u[[x-2,y,z]]);
      u = modarray( u, [x-1,y,z], u[[1,y,z]]);
    }
  }
 
  return(u);
}




#if DISTRIB_LAW_BUG_IS_FIXED

inline double weighted_sum( double[] u, int[] x, double[] w)
{
  res = with( 0*shape(w) <= dx < shape(w) )
        fold( +, u[x+dx-1] * w[dx]);
  return(res);
}

#else
inline double weighted_sum( double[] u, int[3] x, double[4] w)
{
  return(  psi([0],w) * u[x]
         + psi([1],w) * ( u[x+[1,0,0]] + u[x-[1,0,0]]
                      + u[x+[0,1,0]] + u[x-[0,1,0]]
                      + u[x+[0,0,1]] + u[x-[0,0,1]] )
         + psi([2],w) * ( u[x+[1,1,0]] + u[x-[1,1,0]]
                      + u[x+[0,1,1]] + u[x-[0,1,1]]
                      + u[x+[1,0,1]] + u[x-[1,0,1]]
                      + u[x+[-1,1,0]] + u[x-[-1,1,0]]
                      + u[x+[0,-1,1]] + u[x-[0,-1,1]]
                      + u[x+[-1,0,1]] + u[x-[-1,0,1]] )
         + psi([3],w) * ( u[x+[1,1,1]] + u[x-[1,1,1]]
                      + u[x+[-1,1,1]] + u[x-[-1,1,1]]
                      + u[x+[1,-1,1]] + u[x-[1,-1,1]]
                      + u[x+[1,1,-1]] + u[x-[1,1,-1]] ) );
}
#endif


inline double[] relax_kernel( double[] w, double[] u)
{
  r = with( 0*shape(u)+1 <= x <= shape(u)-2)
      modarray( u, x, weighted_sum( u, x, w));
  return(r);
}

double[] relax( double[] u, double[] v)
{
  r = v - relax_kernel( A, u);
  r = setup_periodic_border(r);
  return(r);
}

double[] smooth( double[] z, double[] r)
{
  z = z + relax_kernel( S, r);
  z = setup_periodic_border( z);
  return( z);
}

double[] smooth( double[] r)
{
  z = relax_kernel( S, r);
  z = setup_periodic_border( z);
  return( z);
}

double[] fine2coarse( double[] r)
{
  rn = with( 0*shape(r)+1 <= x<= shape(r) / 2 -1)
       genarray( shape(r) / 2 + 1, weighted_sum( r, 2*x, P));
  rn = setup_periodic_border(rn);
  return(rn);
}

double[] coarse2fine( double[] rn)
{

  r = with( 0*shape(rn) <= iv <= 2*shape(rn)-3  step 0*shape(rn)+2 )
      genarray( 2*shape(rn)-2, rn[iv/2] );

  r = relax_kernel( Q, r);
  r = setup_periodic_border(r);
  return(r);
}



double[] mgrid( double[] r)
{ /*
   * non-coarsest grid: r(k-1) = P r(k)			(fine2coarse)
   *                    z(k-1) = M(k-1) r(k-1)		(recursive solve)
   *                    z(k)   = Q z(k-1)		(coarse2fine)
   *                    r(k)   = r(k) - A z(k)		(relax)
   *                    z(k)   = z(k) + S r(k)          (smooth)
   */
  rn = fine2coarse( r);
  zn = mgrid( rn);
  z  = coarse2fine( zn);
  r  = relax( z, r);
  z  = smooth( z, r);

  return(z);
}

double[S0,S0,S0] mgrid( double[S0,S0,S0] r)
{
  z = smooth( r);
  return( z);
}

double nas_mgrid( double[] u, double[] v, int[] pos, int[] neg, int iter)
{
  for( i=0; i<10; i++)
    v = modarray( v, neg[[i]], -1d);

  for( i=0; i<10; i++)
    v = modarray( v, pos[[i]], 1d);

  v = setup_periodic_border(v);

  r = relax( u, v);

  i = 0;
  
  do {
    
#if USE_SAME_SHORTCUT_AS_IN_FORTRAN
    rn = fine2coarse(r);
    zn = mgrid(rn);
    u  = u + coarse2fine(zn);
    r  = relax(u, v);
    u  = smooth(u, r);
#else
    u  = u + mgrid( r);
#endif

    r  = relax( u, v);
  
    i += 1;
  }
  while (i<iter);

  z = l2norm_inner( r);
  return(z);
}



/*
 * The tricky part of this program is that we want to runthe same
 * executable on different array sizes without re-compilation.
 * Since the current compiler only accepts programs where all
 * shapes involved can be determined statically, we have to use
 * a nesting of conditionals in order to force the compiler
 * to generate the variants we are interested in.
 */
int main()
{
  int[10,3] pos;
  int[10,3] neg;

  size = FibreScanInt();
  iter = FibreScanInt();
  pos  = FibreScanIntArray([10,3]);
  neg  = FibreScanIntArray([10,3]);

  if(size == 256) {
    u_256 = with([0,0,0] <= x <= [S7-1,S7-1,S7-1])
            genarray( [S7,S7,S7], 0d);
    v_256 = with([0,0,0] <= x <= [S7-1,S7-1,S7-1])
            genarray( [S7,S7,S7], 0d);
    z = nas_mgrid(u_256, v_256, pos, neg, iter);
  }
  else{
    if(size == 128) {
      u_128 = with([0,0,0] <= x <= [S6-1,S6-1,S6-1])
              genarray( [S6,S6,S6], 0d);
      v_128 = with([0,0,0] <= x <= [S6-1,S6-1,S6-1])
              genarray( [S6,S6,S6], 0d);
      z = nas_mgrid(u_128, v_128, pos, neg, iter);
    }
    else {
      if(size == 64) {
        u_64 = with([0,0,0] <= x <= [S5-1,S5-1,S5-1])
               genarray( [S5,S5,S5], 0d);
        v_64 = with([0,0,0] <= x <= [S5-1,S5-1,S5-1])
               genarray( [S5,S5,S5], 0d);
        z = nas_mgrid(u_64, v_64, pos, neg, iter);
      }
      else{
        if(size == 32) {
          u_32 = with([0,0,0] <= x <= [S4-1,S4-1,S4-1])
                 genarray( [S4,S4,S4], 0d);
          v_32 = with([0,0,0] <= x <= [S4-1,S4-1,S4-1])
                 genarray( [S4,S4,S4], 0d);
          z = nas_mgrid(u_32, v_32, pos, neg, iter);
        }
        else {
          size = 0;
          iter = 0;
          z = 0d;
        }
      }
    }
  }

  printf( " L2-Norm after %d iteration(s) with max. grid [%d,%d,%d]: %.10e\n", 
          iter, size+2, size+2, size+2, z);

  return( 0);
}

