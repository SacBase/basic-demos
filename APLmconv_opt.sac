import Array: all;
import ArrayIO: all;
import StdIO: all;

/*
 * APL_benchmark: MCONVopt
 *
 * MCONV is a kernel routine from a seismic signal processing application.
 * It implements one-dimensional convolution.
 * The program is a direct translation of a given APL program.
 * Within each SAC function definition, the APL counterpart (in
 * J. Weigang transcription) is given within comments.
 *
 * In contrast to MCONV, this solution aimes at preventing the APL
 * interpreter from creating intermediate arrays of size
 * X * (X+Y)
 *
 * The following flags parameterize the program:
 *
 * X - size of the wavelet as integer value (default 50)
 * Y - size of the trace as integer value (default 10.000)
 *
 * The next two flags are only needed since TC cannot yet do CF:
 *
 * Xm1 - equals (X-1)
 *
 *
 * The following flags require compiler debugging / extension:
 *
 * INL_during_TC_works - define only if inlining is done during type checking, i.e.,
 *                       for "inline" functions, not only shape-specific, but also
 *                       value specific instances are built!
 *
 * INL_FOLD_BUG_IS_FIXED - define only if fold-WL can be inlined error-free!
 *
 *
 * REMARKS:
 * --------
 */

#ifndef X
#define X 50
#endif 
#ifndef Xm1
#define Xm1 49
#endif 
#ifndef Y
#define Y 10000
#endif


/******************************************************************************
 *
 * int[] iota( int[] shp)
 *
 *****************************************************************************/
 
#ifdef INL_during_TC_works
 
  inline int[] iota( int[] shp)
  {
    res = with( . <= [i] <= .)
          genarray( shp, i);
    return( res);
  }
 
#else
 
#define iota(shp) with( . <= [i] <= .) genarray( shp, i)
 
#endif

/******************************************************************************
 *
 * double[] tile( int[] shp, int[] offset, double[] a)
 *
 *****************************************************************************/
 
#ifdef INL_during_TC_works
 
  inline double[] tile( int[] shp, int[] offset, double[] a)
  {
    res = with( . <= iv <= .)
          genarray( shp, a[iv+offset]);
    return( res);
  }
 
#else
 
#define tile(shp,offset,a) with( . <= iv <= .) genarray( shp, a[iv+offset])
 
#endif

/******************************************************************************
 *
 * double[] VxV( double[] v1, double[] v1)
 *
 *****************************************************************************/

#ifdef INL_FOLD_BUG_IS_FIXED

inline double[] VxV( double[] v1, double[] v1)
{
  return( sum( v1*v2));
}

#else

#define VxV(v,m) with(0*shape(v) <= ivv < shape(v)) fold( +, v[ivv] * m[ivv])

#endif

/******************************************************************************
 *
 * double[] VxV_at( int dummy, int[] iv, double[] h, double[] wv)
 *
 *****************************************************************************/

#ifdef INL_FOLD_BUG_IS_FIXED

inline double[] VxV_at( int dummy, int[] iv, double[] h, double[] wv)
{
  /*
   * r{<-}dummy VxVat n
   * @ implements vector product of vector w and a subvector
   * @ of the same size of h, starting at position n.
   * r{<-}(({rho}w){take}n{drop}h)+.{times}w
   */
  res = VxV( wv, tile( shape(wv), iv, h));
  return( res);
}

#else

#define VxV_at(dummy,ivvv,h,wv) tmp = tile( shape(wv), ivvv, h); \
                                val = VxV( wv, tmp)
#endif

/******************************************************************************
 *
 * double[] OP_VxV_at( int scal, int[] vect, double[] h, double[] wv)
 *
 *****************************************************************************/

#ifdef INL_FOLD_BUG_IS_FIXED

inline double[] OP_VxV_at( int scal, int[] vect, double[] h, double[] wv)
{
  res = with( . <= iv <= .) {
          val = VxV_at( scal, iv, h, wv);
        } genarray( shape(vect), val);
  return(res);
}

#else

#define OP_VxV_at(scal,vect,h,wv) with( . <= ivvvv <= .) {\
                                    VxV_at( scal, ivvvv, h, wv); \
                                  } genarray( shape(vect), val)
#endif

/******************************************************************************
 *
 * double[] conv( double[] wz, double[] tr)
 *
 *****************************************************************************/

double[] conv( double[] wz, double[] tr)
{
  /*
   * r{<-}wz conv tr;npad;h;n
   * @ Conv performs standard convolution
   * @ wz is the filter/wavelet vector (usually shorter than tr)
   * @ tr is the seis trace or other vector to be filtered
   * @ conv uses reshape and matrix/vector multiplication.
   * @ Output r is a vector, the filtered/convolved trace.
   * w{<-}wv
   * h{<-}tr,({neg}1+n{<-}{rho}wz){rho}0
   * r{<-}0{jot}.VxVat{iota}{rho}tr
   */
  h = cat( 0, tr, genarray( [Xm1], 0d));

  tmp2 = iota(shape(tr));
  res = OP_VxV_at( 0, tmp2,h,wz);

  return(res);
}

/******************************************************************************
 *
 * int main()
 *
 *****************************************************************************/

int main()
{
  /*
   * r{<-}x mconv y;tr;wz
   * @ Execute convolution problem using big temps
   * @ dcl integer scalar x
   * @ dcl integer scalar y
   * wz{<-}0.01{times}1+{iota}x
   * tr{<-}0.01{times}1+{iota}y
   * r{<-}+/wz conv tr
   */

  wz = 0.01 * (1d + tod(iota([X])));
  tr = 0.01 * (1d + tod(iota([Y])));
  
  res = sum( conv( wz,tr));

  printf( "sum( conv( 0.01 * (1 + tod(iota(%d)), 0.01 * (1 + tod(iota(%d)))) = %f\n",
          X, Y, res);

  return(0);
}
