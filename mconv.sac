import Array: all;
import StdIO: all;

/*
 * sac version for convolution (MCONV)
 *
 * MCONV is a kernel routine from a seismic signal processing application.
 * It implements one-dimensional convolution.
 *
 *
 * The following flags parameterize the program:
 *
 * X - size of the wavelet as integer value (default 50)
 * Y - size of the trace as integer value (default 10.000)
 *
 * The next two flags are only needed since TC cannot yet do CF:
 *
 * Xm1 - equals (X-1)
 * Xm1pY - equals (X-1+Y)
 *
 *
 * The following flags require compiler debugging / extension:
 *
 * INL_during_TC_works - define only if inlining is done during type checking!
 *
 * INL_FOLD_BUG_IS_FIXED - define only if fold-WL can be inlined error-free!
 *
 *
 * REMARKS:
 * --------
 */


#ifndef X
#define X 50
#endif
#ifndef Xm1
#define Xm1 49
#endif
#ifndef Y
#define Y 10000
#endif


/******************************************************************************
 *
 * int[] iota( int[] shp)
 *
 *****************************************************************************/
 
#ifdef INL_during_TC_works
 
  inline int[] iota( int[] shp)
  {
    res = with( . <= [i] <= .)
          genarray( shp, i);
    return( res);
  }
 
#else
 
#define iota(shp) with( . <= [i] <= .) genarray( shp, i)
 
#endif

/******************************************************************************
 *
 * double[] tile( int[] shp, int[] offset, double[] a)
 *
 *****************************************************************************/
 
#ifdef INL_during_TC_works
 
  inline double[] tile( int[] shp, int[] offset, double[] a)
  {
    res = with( . <= iv <= .)
          genarray( shp, a[iv+offset]);
    return( res);
  }
 
#else
 
#define tile(shp,offset,a) with( . <= ivv <= .) genarray( shp, a[ivv+offset])
 
#endif

/******************************************************************************
 *
 * double vec_prod( double[] v1, double[] v2)
 *
 *****************************************************************************/

#ifdef INL_FOLD_BUG_IS_FIXED

inline double vec_prod( double[] v1, double[] v2)
{
  return( sum( v1* v2));
}

#else

#define vec_prod(v1,v2) with( 0*shape(v1) <= ivvv <shape(v1)) \
                        fold( +, v1[ivvv] * v2[ivvv])

#endif

/******************************************************************************
 *
 * double[] conv( double[] wz, double[] tr)
 *
 *****************************************************************************/

double[] conv( double[] wv, double[] tr)
{
  h = cat( 0, tr, genarray( [Xm1], 0d));
  r = with (. <= iv <= .) {
        tile = tile( shape(wv), iv, h);
      } modarray( tr, iv, vec_prod( wv, tile));

  return( r);
}


/******************************************************************************
 *
 * int main()
 *
 *****************************************************************************/

int main()
{
  wz = 0.01 * (1d + tod( iota([X])));
  tr = 0.01 * (1d + tod( iota([Y])));
  
  res = sum( conv( wz,tr));

  printf( "sum( conv( 0.01 * (1d + tod(iota([%d]))), 0.01 * (1d + tod(iota(%d))))) = %f\n",
          X, Y, res);


  return(0);
}


